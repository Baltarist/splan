# PersonalScrum - Mobil ve AI Geliştirme Kuralları

## Mobil Uygulama Geliştirme Kuralları

### React Native Standartları

#### Component Yapısı
```typescript
// ✅ DOGRU: Functional component with TypeScript
import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { useSelector, useDispatch } from 'react-redux';

interface SprintCardProps {
  sprint: Sprint;
  onPress: (sprintId: string) => void;
  isActive?: boolean;
}

const SprintCard: React.FC<SprintCardProps> = ({ 
  sprint, 
  onPress, 
  isActive = false 
}) => {
  const dispatch = useDispatch();
  const { user } = useSelector((state: RootState) => state.auth);

  const handlePress = () => {
    onPress(sprint.id);
  };

  return (
    <View style={[styles.container, isActive && styles.activeContainer]}>
      <Text style={styles.title}>{sprint.title}</Text>
      <Text style={styles.progress}>
        {sprint.completedTasks}/{sprint.totalTasks} tasks completed
      </Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 16,
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    marginBottom: 12,
    elevation: 2, // Android shadow
    shadowColor: '#000', // iOS shadow
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  activeContainer: {
    borderColor: '#007AFF',
    borderWidth: 2,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#1A1A1A',
    marginBottom: 8,
  },
  progress: {
    fontSize: 14,
    color: '#666666',
  },
});

export default SprintCard;
```

#### Navigation Kuralları
```typescript
// ✅ DOGRU: Type-safe navigation
export type RootStackParamList = {
  Home: undefined;
  Login: undefined;
  Register: undefined;
  Dashboard: undefined;
  GoalCreation: { editMode?: boolean; goalId?: string };
  SprintDetails: { sprintId: string };
  AIChat: { context: 'daily' | 'retrospective'; sprintId?: string };
  Settings: undefined;
};

export type MainTabParamList = {
  Dashboard: undefined;
  Sprints: undefined;
  Goals: undefined;
  Analytics: undefined;
  Profile: undefined;
};

// Navigation hook kullanımı
const navigation = useNavigation<NavigationProp<RootStackParamList>>();

const navigateToSprintDetails = (sprintId: string) => {
  navigation.navigate('SprintDetails', { sprintId });
};
```

#### State Management (Redux Toolkit)
```typescript
// ✅ DOGRU: Redux Toolkit slice
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';

interface SprintState {
  sprints: Sprint[];
  currentSprint: Sprint | null;
  loading: boolean;
  error: string | null;
}

const initialState: SprintState = {
  sprints: [],
  currentSprint: null,
  loading: false,
  error: null,
};

// Async thunk for API calls
export const fetchSprints = createAsyncThunk(
  'sprints/fetchSprints',
  async (userId: string, { rejectWithValue }) => {
    try {
      const response = await sprintService.getUserSprints(userId);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const sprintSlice = createSlice({
  name: 'sprints',
  initialState,
  reducers: {
    setCurrentSprint: (state, action: PayloadAction<Sprint>) => {
      state.currentSprint = action.payload;
    },
    updateSprintProgress: (state, action: PayloadAction<{
      sprintId: string;
      completedTasks: number;
    }>) => {
      const sprint = state.sprints.find(s => s.id === action.payload.sprintId);
      if (sprint) {
        sprint.completedTasks = action.payload.completedTasks;
      }
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchSprints.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchSprints.fulfilled, (state, action) => {
        state.loading = false;
        state.sprints = action.payload;
      })
      .addCase(fetchSprints.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      });
  },
});

export const { setCurrentSprint, updateSprintProgress } = sprintSlice.actions;
export default sprintSlice.reducer;
```

### Platform-Specific Development

#### iOS Specific Rules
```typescript
// ✅ DOGRU: iOS özel optimizasyonlar
import { Platform } from 'react-native';

const styles = StyleSheet.create({
  container: {
    flex: 1,
    ...Platform.select({
      ios: {
        paddingTop: 44, // Safe area için
        backgroundColor: '#F2F2F7', // iOS system background
      },
      android: {
        paddingTop: StatusBar.currentHeight || 24,
        backgroundColor: '#FFFFFF',
      },
    }),
  },
  button: {
    ...Platform.select({
      ios: {
        backgroundColor: '#007AFF', // iOS blue
        borderRadius: 8,
      },
      android: {
        backgroundColor: '#6200EE', // Material purple
        borderRadius: 4,
        elevation: 2,
      },
    }),
  },
});

// iOS özel fonksiyonlar
const handleiOSHaptic = () => {
  if (Platform.OS === 'ios') {
    const { ReactNativeHapticFeedback } = require('react-native-haptic-feedback');
    ReactNativeHapticFeedback.trigger('impactMedium');
  }
};
```

#### Android Specific Rules
```typescript
// ✅ DOGRU: Android özel optimizasyonlar
import { BackHandler, ToastAndroid } from 'react-native';

// Android back button handling
useEffect(() => {
  const backAction = () => {
    if (canGoBack) {
      navigation.goBack();
      return true;
    }
    return false;
  };

  const backHandler = BackHandler.addEventListener('hardwareBackPress', backAction);
  return () => backHandler.remove();
}, [canGoBack]);

// Android Toast kullanımı
const showAndroidToast = (message: string) => {
  if (Platform.OS === 'android') {
    ToastAndroid.show(message, ToastAndroid.SHORT);
  }
};
```

### Performance Optimization

#### Memory Management
```typescript
// ✅ DOGRU: Memory leak prevention
useEffect(() => {
  let isSubscribed = true;
  
  const fetchData = async () => {
    try {
      const data = await api.getSprints();
      if (isSubscribed) {
        setSprints(data);
      }
    } catch (error) {
      if (isSubscribed) {
        setError(error.message);
      }
    }
  };

  fetchData();

  return () => {
    isSubscribed = false;
  };
}, []);

// WebSocket connection cleanup
useEffect(() => {
  const ws = new WebSocket('ws://localhost:3000/ai-chat');
  
  ws.onmessage = (event) => {
    const aiMessage = JSON.parse(event.data);
    setMessages(prev => [...prev, aiMessage]);
  };

  return () => {
    ws.close();
  };
}, []);
```

#### List Optimization
```typescript
// ✅ DOGRU: FlatList optimizasyonu
const SprintList: React.FC = () => {
  const keyExtractor = useCallback((item: Sprint) => item.id, []);
  
  const renderItem = useCallback(({ item }: { item: Sprint }) => (
    <SprintCard sprint={item} onPress={handleSprintPress} />
  ), [handleSprintPress]);

  const getItemLayout = useCallback((data: Sprint[] | null | undefined, index: number) => ({
    length: SPRINT_CARD_HEIGHT,
    offset: SPRINT_CARD_HEIGHT * index,
    index,
  }), []);

  return (
    <FlatList
      data={sprints}
      keyExtractor={keyExtractor}
      renderItem={renderItem}
      getItemLayout={getItemLayout}
      removeClippedSubviews={true}
      maxToRenderPerBatch={10}
      updateCellsBatchingPeriod={50}
      windowSize={10}
      initialNumToRender={10}
      onEndReachedThreshold={0.1}
      onEndReached={loadMoreSprints}
    />
  );
};
```

### Offline Support
```typescript
// ✅ DOGRU: Offline data management
import NetInfo from '@react-native-async-storage/async-storage';
import AsyncStorage from '@react-native-async-storage/async-storage';

const useOfflineSupport = () => {
  const [isConnected, setIsConnected] = useState(true);
  const [pendingActions, setPendingActions] = useState<PendingAction[]>([]);

  useEffect(() => {
    const unsubscribe = NetInfo.addEventListener(state => {
      setIsConnected(state.isConnected ?? false);
      
      if (state.isConnected) {
        syncPendingActions();
      }
    });

    return unsubscribe;
  }, []);

  const saveOfflineAction = async (action: PendingAction) => {
    const stored = await AsyncStorage.getItem('pendingActions');
    const actions = stored ? JSON.parse(stored) : [];
    actions.push({ ...action, timestamp: Date.now() });
    await AsyncStorage.setItem('pendingActions', JSON.stringify(actions));
  };

  const syncPendingActions = async () => {
    const stored = await AsyncStorage.getItem('pendingActions');
    if (!stored) return;

    const actions: PendingAction[] = JSON.parse(stored);
    
    for (const action of actions) {
      try {
        await executeAction(action);
      } catch (error) {
        console.error('Failed to sync action:', error);
      }
    }

    await AsyncStorage.removeItem('pendingActions');
  };

  return { isConnected, saveOfflineAction };
};
```

## AI Integration Kuralları

### OpenAI API Integration
```typescript
// ✅ DOGRU: AI Service implementation
interface AIServiceConfig {
  model: 'gpt-4' | 'gpt-3.5-turbo';
  maxTokens: number;
  temperature: number;
  timeout: number;
}

class AIService {
  private config: AIServiceConfig = {
    model: 'gpt-4',
    maxTokens: 1000,
    temperature: 0.7,
    timeout: 30000
  };

  async generateScopeDocument(goal: GoalInput): Promise<ScopeDocument> {
    const prompt = this.buildScopePrompt(goal);
    
    try {
      const response = await this.callOpenAI(prompt, {
        maxTokens: 2000,
        temperature: 0.5, // Daha tutarlı sonuçlar için düşük temperature
      });

      return this.parseScopeResponse(response);
    } catch (error) {
      throw new AIServiceError('Failed to generate scope document', error);
    }
  }

  async generateSprintPlan(
    scope: ScopeDocument, 
    userConfig: UserWorkingConfig
  ): Promise<SprintPlan> {
    const prompt = this.buildSprintPlanPrompt(scope, userConfig);
    
    const response = await this.callOpenAI(prompt, {
      maxTokens: 1500,
      temperature: 0.6,
    });

    return this.parseSprintPlanResponse(response);
  }

  async dailyStandupChat(
    message: string,
    context: DailyContext
  ): Promise<AIResponse> {
    const prompt = this.buildDailyPrompt(message, context);
    
    const response = await this.callOpenAI(prompt, {
      maxTokens: 500,
      temperature: 0.8, // Daha doğal konuşma için yüksek temperature
    });

    return this.parseChatResponse(response);
  }

  private buildScopePrompt(goal: GoalInput): string {
    return `
      Sen bir uzman Scrum Master ve proje yöneticisisin. 
      Kullanıcının hedefi için detaylı bir kapsam dokümanı oluştur.
      
      Hedef: ${goal.title}
      Açıklama: ${goal.description}
      Beklenen Süre: ${goal.estimatedDuration}
      Kullanıcı Deneyimi: ${goal.userExperience}
      
      Aşağıdaki format ile JSON döndür:
      {
        "title": "Proje başlığı",
        "description": "Detaylı açıklama",
        "acceptanceCriteria": ["kriter1", "kriter2"],
        "estimatedEffort": "X hafta",
        "prerequisites": ["gereksinim1"],
        "risks": ["risk1"],
        "definition_of_done": ["tanım1"]
      }
      
      Türkçe ve anlaşılır dil kullan.
    `;
  }

  private buildSprintPlanPrompt(
    scope: ScopeDocument, 
    userConfig: UserWorkingConfig
  ): string {
    return `
      Kapsam dokümanına göre sprint planı oluştur.
      
      Kapsam: ${JSON.stringify(scope)}
      
      Kullanıcı Çalışma Bilgileri:
      - Sprint süresi: ${userConfig.sprintDuration} hafta
      - Haftalık çalışma saati: ${userConfig.weeklyHours} saat
      - Günlük odaklanma kapasitesi: ${userConfig.focusHours} saat
      - Çalışma günleri: ${userConfig.workingDays.join(', ')}
      
      Sprint planını şu formatta döndür:
      {
        "sprints": [
          {
            "sprintNumber": 1,
            "title": "Sprint başlığı",
            "goal": "Sprint hedefi", 
            "tasks": [
              {
                "title": "Task başlığı",
                "description": "Task açıklaması",
                "estimatedHours": 4,
                "priority": "high|medium|low",
                "dependencies": []
              }
            ],
            "estimatedHours": 20
          }
        ]
      }
    `;
  }

  private async callOpenAI(
    prompt: string, 
    options: Partial<AIServiceConfig> = {}
  ): Promise<string> {
    const config = { ...this.config, ...options };
    
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), config.timeout);

    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: config.model,
          messages: [{ role: 'user', content: prompt }],
          max_tokens: config.maxTokens,
          temperature: config.temperature,
        }),
        signal: controller.signal,
      });

      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.status}`);
      }

      const data = await response.json();
      return data.choices[0].message.content;
    } finally {
      clearTimeout(timeoutId);
    }
  }
}
```

### AI Response Processing
```typescript
// ✅ DOGRU: AI response validation ve parsing
interface AIResponseValidator {
  validateScopeDocument(response: string): ScopeDocument;
  validateSprintPlan(response: string): SprintPlan;
  validateChatResponse(response: string): AIResponse;
}

class AIResponseProcessor implements AIResponseValidator {
  validateScopeDocument(response: string): ScopeDocument {
    try {
      const parsed = JSON.parse(response);
      
      // Required fields validation
      const required = ['title', 'description', 'acceptanceCriteria', 'estimatedEffort'];
      for (const field of required) {
        if (!parsed[field]) {
          throw new ValidationError(`Missing required field: ${field}`);
        }
      }

      // Type validation
      if (!Array.isArray(parsed.acceptanceCriteria)) {
        throw new ValidationError('acceptanceCriteria must be an array');
      }

      return {
        ...parsed,
        generatedBy: 'ai-agent',
        createdAt: new Date(),
        version: '1.0',
      } as ScopeDocument;
    } catch (error) {
      throw new AIParsingError('Invalid scope document format', error);
    }
  }

  validateSprintPlan(response: string): SprintPlan {
    try {
      const parsed = JSON.parse(response);
      
      if (!parsed.sprints || !Array.isArray(parsed.sprints)) {
        throw new ValidationError('sprints must be an array');
      }

      // Validate each sprint
      parsed.sprints.forEach((sprint: any, index: number) => {
        if (!sprint.tasks || !Array.isArray(sprint.tasks)) {
          throw new ValidationError(`Sprint ${index + 1} must have tasks array`);
        }

        // Validate tasks
        sprint.tasks.forEach((task: any, taskIndex: number) => {
          if (!task.title || !task.estimatedHours) {
            throw new ValidationError(
              `Task ${taskIndex + 1} in Sprint ${index + 1} missing required fields`
            );
          }
        });
      });

      return parsed as SprintPlan;
    } catch (error) {
      throw new AIParsingError('Invalid sprint plan format', error);
    }
  }

  validateChatResponse(response: string): AIResponse {
    // Chat responses are more flexible, basic validation
    if (!response || response.trim().length === 0) {
      throw new ValidationError('Empty AI response');
    }

    return {
      message: response.trim(),
      timestamp: new Date(),
      context: 'chat',
      suggestions: this.extractSuggestions(response),
    };
  }

  private extractSuggestions(response: string): string[] {
    // Extract actionable suggestions from AI response
    const suggestionPatterns = [
      /Önerim[:\s](.+?)(?:\.|$)/gi,
      /Yapabilirsin[:\s](.+?)(?:\.|$)/gi,
      /Deneyebilirsin[:\s](.+?)(?:\.|$)/gi,
    ];

    const suggestions: string[] = [];
    
    suggestionPatterns.forEach(pattern => {
      const matches = response.matchAll(pattern);
      for (const match of matches) {
        if (match[1]) {
          suggestions.push(match[1].trim());
        }
      }
    });

    return suggestions;
  }
}
```

### Real-time AI Chat
```typescript
// ✅ DOGRU: WebSocket ile AI chat
class AIChatService {
  private ws: WebSocket | null = null;
  private messageQueue: ChatMessage[] = [];
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;

  connect(userId: string): Promise<void> {
    return new Promise((resolve, reject) => {
      this.ws = new WebSocket(`ws://localhost:3000/ai-chat?userId=${userId}`);

      this.ws.onopen = () => {
        console.log('AI Chat connected');
        this.reconnectAttempts = 0;
        this.flushMessageQueue();
        resolve();
      };

      this.ws.onmessage = (event) => {
        const message = JSON.parse(event.data) as AIChatMessage;
        this.handleAIMessage(message);
      };

      this.ws.onclose = () => {
        console.log('AI Chat disconnected');
        this.attemptReconnect(userId);
      };

      this.ws.onerror = (error) => {
        console.error('AI Chat error:', error);
        reject(error);
      };
    });
  }

  sendMessage(message: ChatMessage): void {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    } else {
      // Queue message for when connection is restored
      this.messageQueue.push(message);
    }
  }

  private attemptReconnect(userId: string): void {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      const delay = Math.pow(2, this.reconnectAttempts) * 1000; // Exponential backoff
      
      setTimeout(() => {
        console.log(`Reconnecting AI Chat (attempt ${this.reconnectAttempts})`);
        this.connect(userId);
      }, delay);
    }
  }

  private flushMessageQueue(): void {
    while (this.messageQueue.length > 0) {
      const message = this.messageQueue.shift();
      if (message) {
        this.sendMessage(message);
      }
    }
  }

  private handleAIMessage(message: AIChatMessage): void {
    // Process AI response
    store.dispatch(addAIMessage(message));
    
    // Trigger haptic feedback
    if (Platform.OS === 'ios') {
      HapticFeedback.trigger('notificationSuccess');
    }

    // Show notification if app is in background
    if (AppState.currentState !== 'active') {
      LocalNotification.show({
        title: 'AI Assistant',
        message: message.content.substring(0, 100) + '...',
      });
    }
  }

  disconnect(): void {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
}
```

## Testing Kuralları

### Unit Testing
```typescript
// ✅ DOGRU: React Native component testing
import React from 'react';
import { render, fireEvent, waitFor } from '@testing-library/react-native';
import { Provider } from 'react-redux';
import { store } from '../store';
import SprintCard from '../components/SprintCard';

const mockSprint: Sprint = {
  id: '1',
  title: 'Test Sprint',
  completedTasks: 3,
  totalTasks: 10,
  status: 'active',
};

const renderWithProvider = (component: React.ReactElement) => {
  return render(
    <Provider store={store}>
      {component}
    </Provider>
  );
};

describe('SprintCard', () => {
  it('should render sprint information correctly', () => {
    const onPress = jest.fn();
    const { getByText } = renderWithProvider(
      <SprintCard sprint={mockSprint} onPress={onPress} />
    );

    expect(getByText('Test Sprint')).toBeTruthy();
    expect(getByText('3/10 tasks completed')).toBeTruthy();
  });

  it('should call onPress when tapped', () => {
    const onPress = jest.fn();
    const { getByTestId } = renderWithProvider(
      <SprintCard sprint={mockSprint} onPress={onPress} />
    );

    fireEvent.press(getByTestId('sprint-card'));
    expect(onPress).toHaveBeenCalledWith('1');
  });

  it('should show active state correctly', () => {
    const onPress = jest.fn();
    const { getByTestId } = renderWithProvider(
      <SprintCard sprint={mockSprint} onPress={onPress} isActive={true} />
    );

    const container = getByTestId('sprint-card');
    expect(container.props.style).toMatchObject(
      expect.objectContaining({
        borderColor: '#007AFF',
        borderWidth: 2,
      })
    );
  });
});
```

### AI Service Testing
```typescript
// ✅ DOGRU: AI service mocking
import { AIService } from '../services/AIService';

// Mock OpenAI API
jest.mock('../config/openai', () => ({
  openai: {
    chat: {
      completions: {
        create: jest.fn(),
      },
    },
  },
}));

describe('AIService', () => {
  let aiService: AIService;

  beforeEach(() => {
    aiService = new AIService();
    jest.clearAllMocks();
  });

  describe('generateScopeDocument', () => {
    it('should generate valid scope document', async () => {
      const mockGoal = {
        title: 'Learn React Native',
        description: 'I want to build mobile apps',
        estimatedDuration: '3 months',
        userExperience: 'beginner',
      };

      const mockAIResponse = {
        choices: [{
          message: {
            content: JSON.stringify({
              title: 'React Native Learning Path',
              description: 'Comprehensive learning plan...',
              acceptanceCriteria: ['Complete tutorial', 'Build sample app'],
              estimatedEffort: '12 weeks',
              prerequisites: ['JavaScript knowledge'],
              risks: ['Time management'],
              definition_of_done: ['Deploy to app store'],
            }),
          },
        }],
      };

      (require('../config/openai').openai.chat.completions.create as jest.Mock)
        .mockResolvedValue(mockAIResponse);

      const result = await aiService.generateScopeDocument(mockGoal);

      expect(result.title).toBe('React Native Learning Path');
      expect(result.acceptanceCriteria).toHaveLength(2);
      expect(result.generatedBy).toBe('ai-agent');
    });

    it('should handle AI API errors gracefully', async () => {
      const mockGoal = {
        title: 'Test Goal',
        description: 'Test description',
        estimatedDuration: '1 month',
        userExperience: 'beginner',
      };

      (require('../config/openai').openai.chat.completions.create as jest.Mock)
        .mockRejectedValue(new Error('API Error'));

      await expect(aiService.generateScopeDocument(mockGoal))
        .rejects
        .toThrow('Failed to generate scope document');
    });
  });
});
```

### E2E Testing
```typescript
// ✅ DOGRU: Detox E2E testing
describe('Sprint Management Flow', () => {
  beforeAll(async () => {
    await device.launchApp();
  });

  beforeEach(async () => {
    await device.reloadReactNative();
  });

  it('should create goal and generate sprints with AI', async () => {
    // Login
    await element(by.id('email-input')).typeText('test@example.com');
    await element(by.id('password-input')).typeText('password123');
    await element(by.id('login-button')).tap();

    // Wait for dashboard
    await waitFor(element(by.id('dashboard-screen')))
      .toBeVisible()
      .withTimeout(5000);

    // Create new goal
    await element(by.id('create-goal-button')).tap();
    
    await element(by.id('goal-title-input'))
      .typeText('Learn Mobile Development');
    
    await element(by.id('goal-description-input'))
      .typeText('I want to become a mobile developer and build apps');

    await element(by.id('generate-scope-button')).tap();

    // Wait for AI to generate scope
    await waitFor(element(by.id('scope-document')))
      .toBeVisible()
      .withTimeout(10000);

    // Check if scope document is generated
    await expect(element(by.id('scope-title'))).toBeVisible();
    await expect(element(by.id('acceptance-criteria'))).toBeVisible();

    // Generate sprint plan
    await element(by.id('generate-sprints-button')).tap();

    // Wait for sprint plan
    await waitFor(element(by.id('sprint-plan')))
      .toBeVisible()
      .withTimeout(10000);

    // Verify sprints are created
    await expect(element(by.id('sprint-1'))).toBeVisible();
    await expect(element(by.id('sprint-2'))).toBeVisible();
  });

  it('should handle daily standup with AI', async () => {
    // Navigate to active sprint
    await element(by.id('sprints-tab')).tap();
    await element(by.id('active-sprint-card')).tap();

    // Start daily standup
    await element(by.id('daily-standup-button')).tap();

    // Chat with AI
    await element(by.id('chat-input'))
      .typeText('I completed the React basics task yesterday');
    
    await element(by.id('send-message-button')).tap();

    // Wait for AI response
    await waitFor(element(by.id('ai-message')))
      .toBeVisible()
      .withTimeout(5000);

    // Verify AI responded
    await expect(element(by.id('ai-message'))).toBeVisible();
  });
});
```

## Performance ve Security

### Performance Monitoring
```typescript
// ✅ DOGRU: Performance tracking
import { Performance } from 'react-native-performance';
import { Flipper } from 'react-native-flipper';

class PerformanceMonitor {
  static trackScreenTransition(screenName: string) {
    const startTime = Performance.now();
    
    return {
      end: () => {
        const duration = Performance.now() - startTime;
        console.log(`Screen ${screenName} loaded in ${duration}ms`);
        
        // Log to analytics
        Analytics.track('screen_load_time', {
          screen: screenName,
          duration,
        });

        // Alert if slow
        if (duration > 2000) {
          console.warn(`Slow screen load: ${screenName} took ${duration}ms`);
        }
      },
    };
  }

  static trackAPICall(endpoint: string) {
    const startTime = Performance.now();
    
    return {
      end: (success: boolean) => {
        const duration = Performance.now() - startTime;
        
        Analytics.track('api_call', {
          endpoint,
          duration,
          success,
        });
      },
    };
  }
}

// Usage in components
const DashboardScreen: React.FC = () => {
  useEffect(() => {
    const perfTracker = PerformanceMonitor.trackScreenTransition('Dashboard');
    
    return () => {
      perfTracker.end();
    };
  }, []);

  // Component implementation...
};
```

### Security Kuralları
```typescript
// ✅ DOGRU: Secure storage
import { Keychain } from 'react-native-keychain';
import CryptoJS from 'crypto-js';

class SecureStorage {
  static async storeToken(token: string): Promise<void> {
    await Keychain.setInternetCredentials(
      'personal_scrum_auth',
      'auth_token',
      token
    );
  }

  static async getToken(): Promise<string | null> {
    try {
      const credentials = await Keychain.getInternetCredentials('personal_scrum_auth');
      return credentials ? credentials.password : null;
    } catch (error) {
      return null;
    }
  }

  static async clearToken(): Promise<void> {
    await Keychain.resetInternetCredentials('personal_scrum_auth');
  }

  // Encrypt sensitive user data
  static encryptUserData(data: object): string {
    const jsonString = JSON.stringify(data);
    return CryptoJS.AES.encrypt(jsonString, 'user_data_key').toString();
  }

  static decryptUserData(encryptedData: string): object {
    const bytes = CryptoJS.AES.decrypt(encryptedData, 'user_data_key');
    const decryptedString = bytes.toString(CryptoJS.enc.Utf8);
    return JSON.parse(decryptedString);
  }
}

// ✅ DOGRU: API security
class SecureAPIClient {
  private static async getAuthHeaders(): Promise<HeadersInit> {
    const token = await SecureStorage.getToken();
    return {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json',
      'X-App-Version': Config.APP_VERSION,
      'X-Platform': Platform.OS,
    };
  }

  static async secureRequest(endpoint: string, options: RequestInit = {}) {
    const headers = await this.getAuthHeaders();
    
    const response = await fetch(`${Config.API_BASE_URL}${endpoint}`, {
      ...options,
      headers: { ...headers, ...options.headers },
      timeout: 10000, // 10 second timeout
    });

    if (response.status === 401) {
      // Token expired, redirect to login
      await SecureStorage.clearToken();
      NavigationService.navigate('Login');
      throw new Error('Authentication required');
    }

    if (!response.ok) {
      throw new Error(`API Error: ${response.status}`);
    }

    return response.json();
  }
}
```

Bu kapsamlı mobil ve AI geliştirme kuralları PersonalScrum uygulamasının kaliteli, güvenli ve performanslı olmasını sağlayacaktır. Her bölüm modern best practice'leri takip eder ve özel gereksinimlerinizi karşılar.